`include "{filename}"
module testbench;


{input_output_declarations}

integer num_inputs;
integer num_test_cases;
integer num_clock_cycles;

logic [{max_input_bitwidth}-1:0] inputs[]; 

{test_module_name} simulate_with_verilator_test_module({test_module_port_list});

localparam CLK_PERIOD = 10;
localparam STDIN = 32'h8000_0000;

initial begin
  $fscanf(STDIN, "%d %d %d\n", num_inputs, num_test_cases, num_clock_cycles);
  $display("num_inputs = %d, num_test_cases = %d, num_clock_cycles = %d\n",
    num_inputs, num_test_cases, num_clock_cycles);

  inputs = new[num_inputs];

  for (int i = 0; i < num_test_cases; i++) begin
    // First half of clock cycle 0 (inputs=inputs, clock=0)
    // Note that this evaluation also handles the combinational case.
    for (int j = 0; j < num_inputs; j++) begin
      $fscanf(STDIN, "%X\n", inputs[j]);
    end
    {clear_clock}
    // {display_inputs}
    #CLK_PERIOD;

    // For each requested clock cycle, finish the last half of the current clock
    // cycle and then start the first half of the next clock cycle.
    for (int clk_i = 0; clk_i < num_clock_cycles; clk_i++) begin
      // Second half of cycle clk_i (inputs=random, clock=1)
      // {randomize_inputs} 
      {set_clock}
      #CLK_PERIOD;

      // First half of cycle clk_i+1 (inputs=random, clock=0)
      if (clk_i < num_clock_cycles - 1) begin
        {clear_clock} 
        // {randomize_inputs}
        #CLK_PERIOD;
      end
      {display_outputs}
    end
  end

$finish;
end

endmodule
