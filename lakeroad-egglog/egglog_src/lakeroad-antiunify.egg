;;; Lakeroad language definition with antiunification experiments.

(sort IVec (Vec i64))

;;; Forward-declare Exprs and declare ExprVec.
(sort Expr)
(sort ExprVec (Vec Expr))

; Ops
(datatype Op
  (And)
  (Or)
  (Xor)
  (Shr)
  ; Returns a bitvector of width 1.
  (Eq)
  ; Bitwise not.
  (Not)
  (LogicNot)
  ; (Mux select-expr expr expr)
  (Mux)
  
  ; (Op1 (Extract high low) expr)
  ; Extraction from a bitvector.
  (Extract i64 i64)

  ; (Op2 (Concat) top-expr bottom-expr)
  ; Concatenation of two bitvectors.
  (Concat)
  
  ; (Op2 (Reg init-value) clock-expr data-expr)
  (Reg i64)

  ; (Op0 (BV value bitwidth))
  (BV i64 i64)

  ; (Op1 (ZeroExtend bitwidth) expr)
  (ZeroExtend i64)
  )

(datatype Graph 
  ;;; Hole with a bitwidth.
  ;(Hole i64)
  ;;; TODO need to implement bitwidth. for now too lazy to implement the typechecking.
  (Hole)

  ;;;
  (Op0_ Op)
  (Op1_ Op Graph)
  (Op2_ Op Graph Graph)
  (Op3_ Op Graph Graph Graph)
  )

;;; Module declaration
(sort Module)
;;; IVec is an vector of integers holding De Bruijn indices.
(function MakeModule (Graph IVec) Module)

; Our language. Note that we do not explicitly use IDs as in the Lakeroad paper
; formalization. The IDs are still there, though: they're the 
; eclass IDs!
;(datatype Expr

  ; (Var name bitwidth)
  (function Var (String i64) Expr)
  
  ;;; "Direct" representation of programs:
  ;;; Expressing programs via direct application of Ops to leaf nodes (Vars
  ;;; and Consts).
  ; (OpN op input-expr...)
  (function Op0 (Op) Expr)
  (function Op1 (Op Expr) Expr)
  (function Op2 (Op Expr Expr) Expr)
  (function Op3 (Op Expr Expr Expr) Expr)


  ; (Wire name bitwidth)
  (function Wire (String i64) Expr)
  
  ;;; 
  (function apply (Module ExprVec) Expr)
  ;)

;;; Types for Lakeroad expressions.
(datatype Type
  ;;; Bitvector type.
  (Bitvector i64)
  ;;; Module type: when `apply`ed, gives back the indicated type. This could be
  ;;; a lot more rigorous. Currently will not allow for checking correct input
  ;;; types.
  (ModuleType Type))

;;; Indicates that a Lakeroad expression has a given type.
(relation HasType (Expr Type))

;;; Indicates that all input and output bitwidths must match for this type of 
;;; op.
(relation AllBitwidthsMatch (Op))
(AllBitwidthsMatch (And))
(AllBitwidthsMatch (Or))
(AllBitwidthsMatch (Xor))
(AllBitwidthsMatch (Shr))
; Have to write this one as a rule, unfortunately.
(ruleset core)
(rule ((Reg n)) ((AllBitwidthsMatch (Reg n))) :ruleset core)

;;; Indicates that, for the op, the input bitwidths must match, and the output
;;; bitwidth is the indicated constant.
(relation InputBitwidthsMatchOutputBitwidthConst (Op i64))
(InputBitwidthsMatchOutputBitwidthConst (Eq) 1)

;;; Bitwise: Indicates that an op `(op a b ...)` can be written 
;;; `(concat (op a[0] b[0] ...) (op a[1] b[1] ...) ...)`.
(relation Bitwise (Op))
(Bitwise (And))
(Bitwise (Or))
(Bitwise (Xor))


;;; Typing judgements.
(ruleset typing)
(rule
  ((Wire name bw))
  ((HasType (Wire name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Var name bw))
  ((HasType (Var name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op0 (BV val bw)))
  ((HasType (Op0 (BV val bw)) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op1 op i0)
   (HasType i0 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op1 op i0) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 op i0 i1)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op2 op i0 i1) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op3 op i0 i1 i2)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (HasType i2 (Bitvector bw))
   (AllBitwidthsMatch op))
  ((HasType (Op3 op i0 i1 i2) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op1 op i0)
   (HasType i0 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op1 op i0) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op2 op i0 i1)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op2 op i0 i1) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op3 op i0 i1 i2)
   (HasType i0 (Bitvector bw))
   (HasType i1 (Bitvector bw))
   (HasType i2 (Bitvector bw))
   (InputBitwidthsMatchOutputBitwidthConst op out-bw))
  ((HasType (Op3 op i0 i1 i2) (Bitvector out-bw)))
  :ruleset typing)
(rule
  ((Op3 (Mux) sel-expr a-expr b-expr)
   (HasType sel-expr (Bitvector 1))
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op3 (Mux) sel-expr a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Concat) a-expr b-expr)
   (HasType a-expr (Bitvector m))
   (HasType b-expr (Bitvector n)))
  ((HasType (Op2 (Concat) a-expr b-expr) (Bitvector (+ m n))))
  :ruleset typing)
(rule
  ((Op1 (Extract high low) expr)
   (HasType expr (Bitvector n))
   (>= 0 low)
   (< high n))
  ((HasType (Op1 (Extract high low) expr) (Bitvector (+ 1 (- high low)))))
  :ruleset typing)
(rule
  ((Op1 (ZeroExtend bitwidth) expr))
  ((HasType (Op1 (ZeroExtend bitwidth) expr) (Bitvector bitwidth)))
  :ruleset typing)

;;; Rewrites that are likely to expand the egraph.
(ruleset expansion)
(rule 
 ((Op2 op e1 e2)
  (Bitwise op)
  (HasType (Op2 op e1 e2) (Bitvector n))
  (> n 1))
 ((union
   (Op2 op e1 e2)
   (Op2 (Concat) 
    (Op2 op 
     (Op1 (Extract (- n 1) 1) e1) (Op1 (Extract (- n 1) 1) e2))
    (Op2 op 
     (Op1 (Extract 0 0) e1) (Op1 (Extract 0 0) e2))))))