;;; Lakeroad language definition with antiunification experiments.


; Ops
(datatype Op
  (And)
  (Or)
  (Xor)
  (Shr)
  ; Returns a bitvector of width 1.
  (Eq)
  (LogicNot)
  ; (Mux select-expr expr expr)
  (Mux)
  
  ; (Op1 (Extract high low) expr)
  ; Extraction from a bitvector.
  (Extract i64 i64)

  ; (Op2 (Concat) top-expr bottom-expr)
  ; Concatenation of two bitvectors.
  (Concat)
  
  ; (Op2 (Reg init-value) clock-expr data-expr)
  (Reg i64)

  ; (Op0 (BV value bitwidth))
  (BV i64 i64)
  )

; Our language. Note that we do not explicitly use IDs as in the Lakeroad paper
; formalization. The IDs are still there, though: they're the 
; eclass IDs!
(datatype Expr

  ; (Var name bitwidth)
  (Var String i64)
  
  ;;; "Direct" representation of programs:
  ;;; Expressing programs via direct application of Ops to leaf nodes (Vars
  ;;; and Consts).
  ; (OpN op input-expr...)
  (Op0 Op :cost 100000000)
  (Op1 Op Expr :cost 100000000)
  (Op2 Op Expr Expr :cost 100000000)
  (Op3 Op Expr Expr Expr :cost 100000000)


  ; (Wire name bitwidth)
  ; Wire is a placeholder for another expression. See below how 
  ; wires are the key to creating cyclic graphs.
  (Wire String i64)
  ; (ZeroExtend expr bitwidth)
  (ZeroExtend Expr i64)
  
  ; (Sketch sketch-id input-expr...)
  ; A sketch node. This is a proposal for a potential expression, that will
  ; need to be solved for/made concrete later on.
  ;(Sketch1 SketchOp Expr)
  ;(Sketch2 SketchOp Expr Expr)
  ;(Sketch3 SketchOp Expr Expr Expr)
  ;(Sketch4 SketchOp Expr Expr Expr Expr)
  )

;;; Types for Lakeroad expressions.
(datatype Type
  ;;; Bitvector type.
  (Bitvector i64))

