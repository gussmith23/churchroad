;;; Lakeroad language definition, for importing before running other tests.

; Ops
(datatype Op
  (And)
  (Or)
  (Eq)
  (LogicNot)
  ; (Mux select-expr expr expr)
  (Mux))

; Our language. Note that we do not explicitly use IDs as in Zach's
; formalization. The IDs are still there, though: they're the 
; eclass IDs!
(datatype Expr
  ; (BV value bitwidth)
  (BV i64 i64)
  ; (Var name bitwidth)
  (Var String i64)
  ; (OpN op input-expr...)
  (Op1 Op Expr)
  (Op2 Op Expr Expr)
  (Op3 Op Expr Expr Expr)
  ; (Reg default-value clock-expr d-expr)
  (Reg i64 Expr Expr)
  ; (Wire name bitwidth)
  ; Wire is a placeholder for another expression. See below how 
  ; wires are the key to creating cyclic graphs.
  (Wire String i64)
  ; (Extract high low expr)
  ; Extracts expr[high:low] using inclusive ranges as in Rosette/Verilog.
  (Extract i64 i64 Expr)
  ; (Concat expr expr)
  (Concat Expr Expr)
  ; (ZeroExtend expr bitwidth)
  (ZeroExtend Expr i64))

;;; Types for Lakeroad expressions.
(datatype Type
  ;;; Bitvector type.
  (Bitvector i64))

;;; Indicates that a Lakeroad expression has a given type.
(relation HasType (Expr Type))

;;; Typing judgements.
(ruleset typing)
(rule
  ((Var name bw))
  ((HasType (Var name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((BV name bw))
  ((HasType (BV name bw) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Reg default clk-expr d-expr)
   ; Currently require clock to be one bit.
   (HasType clk-expr (Bitvector 1))
   (HasType d-expr (Bitvector bw)))
  ((HasType (Reg default clk-expr d-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (And) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (And) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Or) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Or) a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Op2 (Eq) a-expr b-expr)
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op2 (Eq) a-expr b-expr) (Bitvector 1)))
  :ruleset typing)
(rule
  ((Op3 (Mux) sel-expr a-expr b-expr)
   (HasType sel-expr (Bitvector 1))
   (HasType a-expr (Bitvector bw))
   (HasType b-expr (Bitvector bw)))
  ((HasType (Op3 (Mux) sel-expr a-expr b-expr) (Bitvector bw)))
  :ruleset typing)
(rule
  ((Concat a-expr b-expr)
   (HasType a-expr (Bitvector m))
   (HasType b-expr (Bitvector n)))
  ((HasType (Concat a-expr b-expr) (Bitvector (+ m n))))
  :ruleset typing)
(rule
  ((Extract high low expr)
   (HasType expr (Bitvector n)))
  ((HasType (Extract high low expr) (Bitvector (+ 1 (- high low)))))
  :ruleset typing)
(rule
  ((ZeroExtend expr bitwidth))
  ((HasType (ZeroExtend expr bitwidth) (Bitvector bitwidth)))
  :ruleset typing)